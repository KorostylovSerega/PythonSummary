# Содержание
- [1. Характеристика языка Python](https://github.com/KorostylovSerega/PythonSummary/edit/main/python.md#1-Характеристика-языка-Python)
- [2. Типы данных в Python](https://github.com/KorostylovSerega/PythonSummary/edit/main/python.md#2-Типы-данных-в-Python)

## 1. Характеристика языка Python

### Высокоуровневый интерпретируемый язык общего назначения, со строгой динамической типизацией.
`Высокоуровневый` - разрабатанный для удобства использования и скорости написания программы. В них применяются определённые абстракции — структуры данных, набор вспомогательных функций (прим. Python, JS, PHP, Go). Низкоуровневые языки, в свою очередь, близки к машинному коду или его конструкциям (прим. C, Assembler, Forth).

`Интерпретируемый` - язык, код которого выполняется специальной программой интерпретатором. Интерпретатор построчно анализирует, обрабатывает и выполняет исходный код программы (прим. Python, JS, PHP, R, Ruby). Компилируемые языки, перед запуском программы, анализируют и транслируют исходный код в машинный или байт-код без её выполнения (С, С++, Pascal).

`Строгая типизация` - предполагает отсутствие конверсии типов. То есть, при выполнении команд, интерпретатор не станет неявно приводить типы в отличии от слабо типизированных языков, в которых конверсия типа может происходить неявно.
```
--- Python ---
a = 1         # int
b = "1"       # str
print(a + b)  # TypeError: unsupported operand type(s) for +: 'int' and 'str'

--- JS ---
a = 1               // number
b = "1"             // string
console.log(a + b)  // "11"
```

`Динамическая типизация` - предполагает, что в процессе выполнения кода переменная может содержать объекты различных типов. То есть, при объявлении переменой не нужно явно указывать, какой тип данных в ней будет храниться (прим. Python, Ruby, PHP, JavaScript). Статическая типизация предполагает, что при задании переменной сразу указывается тип данных, который она может содержать (прим. C, C++, C#, Java, Go).
```
--- Python ---
a = 100            # int
a = "one hundred"  # str
print(a)           # "one hundred"

--- C# ---
int a;
a = 100;            // int32
a = "one hundred";  // error CS0029: Cannot implicitly convert type 'string' to 'int'
Console.Write(a);

```
Переменные в Python не являются контейнерами для данных, и не содержат информации о типе. Переменные в Python - это имена которые ссылаются на объекты в памяти.
```
print(hex(id(1)))  # 0xa3eb08 - адресс в памяти объекта '1'
print(hex(id(2)))  # 0xa3eb28 - адресс в памяти объекта '2'
a = 1              # (name binding) связывание имени 'a' с объектом '1'
print(a)           # 1 - значение объекта на который ссылается имя 'a'
print(hex(id(a)))  # 0xa3eb08 - адресс объекта '1' на который ссылается имя 'a'
a = 2              # (name binding) связывание имени 'a' с объектом '2'
print(a)           # 2 - значение объекта на который ссылается имя 'a'
print(hex(id(a)))  # 0xa3eb28 - адресс объекта '1' на который ссылается имя 'a'
print(hex(id(1)))  # 0xa3eb08 - адресс в памяти объекта '1', который продолжает существовать, но уже не связан с именем 'a'
```
На один и тот же объект могут ссылаться одновременно несколько переменных.
```
a = 1
print(hex(id(a))) # 0xa3eb08
b = a
print(hex(id(b))) # 0xa3eb08
c = b
print(hex(id(c))) # 0xa3eb08
```
[⬆️Содержание](https://github.com/KorostylovSerega/PythonSummary/edit/main/python.md#содержание)

## 2. Типы данных в Python
### Типы данных в Python можно разделить на две большие группы, `изменяемые` и `неизменяемые`.
#### `Изменяемые`
- Списки (list)
- Словари (dict)
- Множества (set)
- Байтовые массивы (bytearray)
#### `Неизменяемые`
- Числа (int, float, complex)
- Строки (str, bytes)
- Кортежи (tuple)
- Неизменяемые множества (frozenset)
- Логический тип данных (bool)
- NoneType

Изменяемые объекты можно изменить после их содания. При попытке изменить объект НЕзменяемого типа, будет создан новый объект в памяти.
```
--- НЕизменяемый тип данных ---
a = 100       # int
print(a)      # 100
print(id(a))  # 10745704

a += 50       # int
print(a)      # 150
print(id(a))  # 10747304

--- Изменяемый тип данных ---
a = [100]     # list
print(a)      # [100]
print(id(a))  # 139917647149120

a += [50]     # list
print(a)      # [100, 50]
print(id(a))  # 139917647149120
```
При связывании переменной с объектом `изменяемого` типа, интерпретатор всегда будет создавать новый объект в памяти. Когда переменная связывается с объектом `неизменяемого` типа, интерпретатор будет проверять наличие в памяти объекта с таким значением, и в случае если такой объект существует, переменная будет ссылаться на него, и новый объект не будет создан (оптимизация реализована на уровне CPython). Интернирование происходит на этапе компиляции python-кода в байт-код. Не будут интернированы строки (str) более 4096 символов, и кортежи (tuple) более 256 элементов.
```
--- НЕизменяемый тип данных --- (Справедливо при компиляции кода как единого блока)
a = 500       # int
print(id(a))  # 139949504653520
b = 500       # int
print(id(b))  # 139949504653520
c = 500       # int
print(id(c))  # 139949504653520

--- Изменяемый тип данных ---
a = [500]     # list
print(id(a))  # 140372319912384
b = [500]     # list
print(id(b))  # 140372319977728
c = [500]     # list
print(id(c))  # 140372319927616

--- Интернирование строк ---
a = 'a' * 4096
print(id(a)) # 44060960
b = 'a' * 4096
print(id(b)) # 44060960

a = 'a' * 4097 # 44071376
print(id(a))
b = 'a' * 4097 # 44075536
print(id(b))

--- Интернирование кортежей ---
a = (1,) * 256 # 43047440
print(id(a))
b = (1,) * 256 # 43047440
print(id(b))

a = (1,) * 257 # 44071392
print(id(a))
b = (1,) * 257 # 44073504
print(id(b))
```
Исключением в данном алгоритме будет являться `неизменяемая` последовательность (tuple), элементом которой будет являться объект `изменяемого` типа. В таком случае интерпретатор, как и с объектами `изменяемого` типа, создаст новый объект.
```
--- Все элементы неизменяемого типы ---
a = (1, 2, 3)  # tuple
print(id(a))   # 139821248616768
b = (1, 2, 3)  # tuple
print(id(b))   # 139821248616768

--- Присутствует элемент изменяемого типа ---
a = (1, 2, [3])  # tuple
print(id(a))     # 140016145357056
b = (1, 2, [3])  # tuple
print(id(b))     # 140016145392896
print(a == b)    # True
```
Так же при запуске интерпретатора будут автоматически созданы числовые объекты в диапазоне от -5 до 256 включительно, и переменные с эквивалентным значением будут ссылаться на эти объекты, не зависимо то того компилировались они единым блоком или нет.
```
--- Переменные ссылается на один объект ---
> a = -5
> b = -5
> id(a)  # 10742344
> id(b)  # 10742344
  
> a = 256
> b = 256
> id(a)  # 10750696
> id(b)  # 10750696

--- Переменные ссылается на разные объекты ---
> a = -6
> b = -6
> id(a)  # 139661811195696
> id(b)  # 139661811198640

> a = 257
> b = 257
> id(a)  # 139661811198640
> id(b)  # 139661811198992
```
